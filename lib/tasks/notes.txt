Tips###Postgres###\\pset format unaligned, html, latex, aligned: changes the format of display.<br/>\\o to send output to a file.<br/><br/>sudo apt-get install --reinstall<br/>script/cucumber_selenium features/region_specific_content.feature <br/>rvm use ruby-1.8.7-p72@projectdx<br/> gem which factory_girl<br/> gem spec factory_girl<br/> git remote update<br/> git reset --hard origin/95904-region-context-without-address<br/><br/>To SSH to alpha:  ssh projectdx@alpha1<br/>To SSH to prod: Go to Alpha and ssh projectdx@prod1<br/><br/>MOM Database dumps: <br/>  ssh projectdx@mom.renewfund.com<br/>  cd /data/development/db_dumps<br/><br/>Backup Projectdx CMS<br/>1. ssh projectdx@alpha.renewfund.com<br/>2. pg_dump -U projectdx cms > cms-10-4-2010.dump<br/>3. psql -U projectdx -d projectdx_cms_dev -f cms-10-4-2010.dump <br/><br/><br/>To dump database schema off remote machine: dev1.renewfund.com:<br/>  pg_dump -s -h dev1.renewfund.com -U projectdx projectdx_dev -c > devschema.dump<br/><br/>To Restore schema: <br/>  RAILS_ENV=test rake db:drop<br/>  RAILS_ENV=test rake db:create <br/>  psql -Uprojectdx -d projectdx_test < devschema.dump<br/><br/><br/>List remote Databases: <br/>  psql -h dev1.renewfund.com -U projectdx -l<br/><br/>Open psql in remote database:<br/>  psql -h dev1.renewfund.com -U projectdx projectdx_test<br/>  psql -h dev1.renewfund.com -U projectdx projectdx_dev<br/><br/>To find references of git (when you make a mistake by killing a branch) <br/>- Get the log list from here:<br/>- cat .git/logs/refs/heads/101022-cms-news<br/>- Chery pick the branch commit number.<br/><br/>To Scan input and extract fourth term<br/>  awk '{print $4}' > ../failing<br/><br/>To Replace specific content of all files<br/>  find . -name *.erb | xargs sed -i 's/sytlesheet/stylesheet/'<br/><br/>To insert content at the first line of each file:<br/>  find . -name *.rb | xargs sed -i '1i #© Copyright, 2010, Zaytona.com, LLC' 
SELECT###Postgres###Select DISTINCT: selects distinct row. <br/>Select DISTINCT ON(): select distinct rows based on a set of fields.
Setup Cucumber Database###Rails####!/usr/bin/env ruby<br/><br/>cuke_env = ARGV.first<br/><br/>%x{dropdb -U projectdx projectdx_\#{cuke_env}}<br/>%x{createdb -U projectdx -T projectdx_test projectdx_\#{cuke_env}}
Address in DelNorte###RF###284 Fresno St, Crescent City, California 95531
Restore Corrupt GIT Repo###GIT###I had managed to destroy my GIT repo on Dropbox, but I had a copy locally. The copy had all the branches cached locally including the origin/xxx branches (which are a cached of the remote branch).<br/><br/>The following article helped:<br/>http://stackoverflow.com/questions/2166005/how-to-restore-git-repository<br/><br/>In order to restore it (to github):<br/><br/>1. Create an empty repo (git init --bare) or use github.<br/>2. Go to the local saved .git folder, and edit .git/config,<br/>3. Point the url of origin to the repo you just created,<br/>4. Run the following from the bash console:<br/><br/>for i in $(git branch -r | grep origin | sed 's#origin/##'); do git checkout $i; git push origin $i; done<br/><br/>This will checkout the branches locally and then push them to origin on the remote repo.<br/>
CAST###Postgres###Casts a value as a specific type.<br/>SELECT CAST('02/05/1984' as date);
LIKE and ILIKE delimters###Postgres###LIKE for wildcard matching<br/>ILKIE for case insensitive wildcard matching<br/>(_) Underscore to match a single character<br/>(%) for wild pattern<br/><br/>Regex
COALESCE###Postgres###Within a list, will find the first non-NULL value<br/>COALESCE(column1, column2, column3, 'Unknown')<br/>= <br/>CASE<br/>  when column1 != NULL then column1<br/>  when column2 != NULL then column2<br/>  when column3 != NULL then column3<br/>  else 'Unknown'<br/>END
ORDER BY [USING operator]###Postgres###Usually, ORDER BY uses the relational operators for comparison, the USING allows for using a different predicate operator for ordering the rows.<br/>
Aggregate###Postgres###COUNT(*): counts all rows<br/>COUNT(expression): counts rows with expression != NULL: select COUNT(balance) from customers;<br/>COUNT (ALL expression): Same as COUNT(expresssion)<br/>COUNT(DISTINCT expression): counts number of distinct non-NULL rows.<br/><br/>SUM(expression), AVG(expression), MIN(expression), MAX(expression): <br/>    Works on a single expression (not entire row) - ignores NULL<br/><br/>STDDEV(expression), VARIANCE(expression): 
Where vs. Having###Postgres###http://www.codeproject.com/KB/database/Where_Vs_Having_Clause.aspx<br/><br/>If a condition refers to an aggregate function, put that condition in the HAVING clause. Otherwise, use the WHERE clause.<br/><br/>Here's another rule: You can't use HAVING unless you also use GROUP BY.<br/><br/>Now, go back to the first example, where WHERE and HAVING produce the same result set. What's the difference? The first query uses the WHERE clause to restrict the number of rows that the computer has to sum up. But the second query sums up all the rows in the table, then uses HAVING to discard the sums it calculated for all states except Texas and Georgia. The first query is obviously the better one, because there is no need to make the computer calculate sums and then throw them away. <br/><br/><br/>Introduction<br/><br/>We always get confused between WHERE and Having clause and make mistakes. Here in this article, I will try to highlight all the major differences between WHERE and HAVING, and things you should be aware of, when using either WHERE or HAVING.<br/><br/>------------------------------------------------------------------------------<br/><br/>Most of the time you will get the same result with Where or Having . The below given two SQL command produces the same result set That is, both count the number of records found for the states of California and Los Angles.<br/><br/>SELECT state, COUNT(*)<br/>FROM Test<br/>WHERE state IN ('CA', 'LA')<br/>GROUP BY state<br/>ORDER BY state<br/><br/>SELECT state, COUNT(*)<br/>FROM Test<br/>GROUP BY state<br/>HAVING state IN ('CA', 'LA')<br/>ORDER BY state<br/>Background<br/><br/>(Optional) So, where is the difference ,Which is better? I'll let you answer those questions in a minute.<br/><br/>The main reason for using WHERE clause is to select rows that are to be included in the query. For example, assume table Test.Suppose I want the names, account numbers, and balance due of all customers from California and Los Angles. Since STATE is one of the fields in the record format, I can use WHERE to select those customers.<br/>Using the code<br/><br/>SELECT cusnum, lstnam, init<br/>FROM Test<br/>WHERE state IN ('CA', 'LA')<br/><br/>CUSNUM LSTNAM INIT BALDUE<br/>====== ============ ==== ========<br/>938472 John G K 37.00<br/>938485 Mark J A 3987.50<br/>593029 Lily E D 25.00<br/><br/><br/>Suppose I want the total amount due from customers by state. In that case, I would need to use the GROUP BY clause to build an aggregate query.<br/><br/>SELECT state,SUM(baldue)<br/>FROM Test<br/>GROUP by state<br/>ORDER BY state<br/><br/>State Sum(Baldue)<br/>===== ===========<br/>CA 250.00<br/>CO 58.75<br/>GA 3987.50<br/>MN 510.00<br/>NY 589.50<br/>TX 62.00<br/>VT 439.00<br/>WY .00<br/><br/>Points of Interest<br/><br/>Suppose I want the same information, but I don't care about states where nobody owes me any money. Since the total owed by state is an aggregate figure, i.e., the figure is generated from a group of records, you must use HAVING to select the proper data.<br/><br/>SELECT state,SUM(baldue)<br/>FROM Test<br/>GROUP by state<br/>HAVING SUM(baldue) > 0<br/>ORDER BY state<br/><br/>State Sum(Baldue)<br/>===== ===========<br/>CA 250.00<br/>CO 58.75<br/>GA 3987.50<br/>MN 510.00<br/>NY 589.50<br/>TX 62.00<br/>VT 439.00 
If else: Based on success/failure of previous command###BASH####/bin/bash <br/><br/>/bin/tar cvfz /test-bkp.tar.gz /opt*.dat <br/><br/>if [ $? -eq 0 ] <br/>then <br/>echo \"backup is Successful \" <br/>echo -e \"Backup path on NAS server is projects\" <br/>else <br/>echo \" backup failed \"  <br/>fi  
Find and Remove folders###BASH###find . -name *.svn* -exec rm -rf {} \\;<br/><br/>Note the \\; at the end.
VIM Tips###VIM###Select All: ggVG<br/>Switch Buffers: Ctrl-w - L or R<br/>Resize buffer: Ctrl - L,K,J, H
Correlated queries###SQL###Using Where with multiple columns <br/>select z.id, a.id, a.zipcode_id from addresses a, zipcodes z where (z.id, a.zipcode_id) = (a.id, z.id) limit 100;<br/><br/>Use multiple conditions on the JOIN:<br/>SELECT * FROM A join B on ((A.id < B.id) AND (A.age > B.age));<br/><br/>Use inner queries (customers with the biggest rating): Uncorrelated query<br/>- Only need to evaluate inner query only once, and use it multiple times.<br/>SELECT C1.Number<br/>FROM Customer C1<br/>WHERE C1.CRating = (SELECT MAX(C2.CRating) FROM Customer C2);<br/><br/>SOME: One or more (exists(1)):<br/>SELECT S.Number, S.Name<br/>FROM Salesperson S<br/>WHERE S.Name = SOME (SELECT C.Name from Customers C);<br/><br/>ALL: <br/><br/>IN:<br/>SELECT S.Number, S.Name<br/>FROM Salesperson S<br/>WHERE S.Name IN (SELECT C.Name from Customers C);<br/><br/>
Floorplanning######<br/>http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5545492&isnumber=&tag=1
Floorplanning###Paper###<br/>http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5545492&isnumber=&tag=1
CKEDITOR Plugin###CKEDITOR###http://www.sayopenweb.com/plugin-for-ckeditor/
Rspec Slides###RSPEC###http://kerryb.github.com/iprug-rspec-presentation/#65
Gem with Active Record###RSPEC###1. $:.unshift File.expand_path('../lib', __FILE__) <br/><br/>Add lib folder to path<br/><br/>  2 ENV['RAILS_ENV']='test'                                                                                                 <br/>  3 require 'fileutils'                                                                                                     <br/>  4 require 'rubygems'                                                                                                      <br/>  5 require 'bundler'                                                                                                       <br/>  6 require 'bundler/setup'                                                                                                 <br/>  7 require 'rspec'                                                                                                         <br/>  8 require 'active_record'                                                                                                 <br/>  <br/>Load active record here and in Gemfile.<br/>                                                                                                                        <br/> 10 Dir[\"\#{File.expand_path('../../lib', __FILE__)}/*.rb\"].each do |file|                                                   <br/> 11   require file                                                                                                          <br/> 12 end                                                                                                                     <br/><br/> This requires all the files within this path.<br/>
Listen to TCP channel###Linux### sudo tcpdump -l -i lo0 -w - src or dst port 3000 | strings
Hidden Weighted Trit Functions###Quantum###you are in... Main\\hwbN functions<br/><br/>Hidden weighted bit function hwbN has N inputs and N outputs. Its output equals its input shifted left on the number of positions equal to the number of ones in the input pattern. Thus, hwbN function is reversible. Hidden weighted bit function is known to have an exponential size BDD for any variable ordering. This type functions were first proposed as reversible benchmarks by Patel and Markov. It is known that hwbN functions may be implemented with polynomial quantum/reversible cost assuming a logarithmic number of garbage bits is available. It remains an open question if a polynomial cost reversible/quantum implementation exists if addition of garbage bits is not allowed.<br/><br/>This is our adaptation to the ternary domain:<br/><br/>HWT3:<br/><br/>0\t0\t0\t\t0\t0\t0<br/>0\t0\t1\t\t0\t1\t0<br/>0\t0\t2\t\t0\t2\t0<br/>0\t1\t0\t\t1\t0\t0<br/>0\t1\t1\t\t1\t0\t1<br/>0\t1\t2\t\t2\t0\t1<br/>0\t2\t0\t\t2\t0\t0<br/>0\t2\t1\t\t1\t0\t2<br/>0\t2\t2\t\t2\t0\t2<br/>1\t0\t0\t\t0\t0\t1<br/>1\t0\t1\t\t1\t1\t0<br/>1\t0\t2\t\t2\t1\t0<br/>1\t1\t0\t\t0\t1\t1<br/>1\t1\t1\t\t1\t1\t1<br/>1\t1\t2\t\t1\t1\t2<br/>1\t2\t0\t\t0\t1\t2<br/>1\t2\t1\t\t1\t2\t1<br/>1\t2\t2\t\t1\t2\t2<br/>2\t0\t0\t\t0\t0\t2<br/>2\t0\t1\t\t1\t2\t0<br/>2\t0\t2\t\t2\t2\t0<br/>2\t1\t0\t\t0\t2\t1<br/>2\t1\t1\t\t2\t1\t1<br/>2\t1\t2\t\t2\t1\t2<br/>2\t2\t0\t\t0\t2\t2<br/>2\t2\t1\t\t2\t2\t1<br/>2\t2\t2\t\t2\t2\t2<br/><br/>
VIMRC: Why VIM autocomplete did not work###VIM###For some strange reason, when I had 'set paste' in the file, VIM did not add the 'end' tag after<br/>I typed def test (and then hit enter).<br/><br/><br/>This is my VIMRC file<br/><br/><br/>call pathogen#runtime_append_all_bundles()<br/><br/>set nocompatible          \" We're running Vim, not Vi!<br/>syntax on                 \" Enable syntax highlighting<br/>filetype plugin indent on \" Enable filetype-specific indenting and plugins<br/><br/>\" Load matchit (% to bounce from do to end, etc.)<br/>runtime! macros/matchit.vim<br/><br/>augroup myfiletypes<br/>  \" Clear old autocmds in group<br/>  autocmd!<br/>  \" autoindent with two spaces, always expand tabs<br/>  autocmd FileType ruby,eruby,yaml set ai sw=2 sts=2 et<br/>augroup END<br/><br/>set hidden<br/>set directory=/tmp<br/>set backupdir=/tmp<br/>set tabstop=2<br/>set shiftwidth=2<br/>set expandtab<br/>set autoindent<br/>set nu<br/>colorscheme ir_black<br/><br/>nnoremap <silent> <F8> :TlistToggle<CR><br/>vmap r \"_dP<br/><br/>map <F2> :NERDTreeToggle<CR><br/><br/>nnoremap <Leader>T :CommandTFlush <CR><br/>nnoremap <Leader>t :CommandT <CR><br/>nnoremap <Leader>a :Ack <br/><br/>if (&tildeop)<br/>  nmap gcw guw~l<br/>  nmap gcW guW~l<br/>  nmap gciw guiw~l<br/>  nmap gciW guiW~l<br/>  nmap gcis guis~l<br/>  nmap gc$ gu$~l<br/>  nmap gcgc guu~l<br/>  nmap gcc guu~l<br/>  vmap gc gu~l<br/>else<br/>  nmap gcw guw~h<br/>  nmap gcW guW~h<br/>  nmap gciw guiw~h<br/>  nmap gciW guiW~h<br/>  nmap gcis guis~h<br/>  nmap gc$ gu$~h<br/>  nmap gcgc guu~h<br/>  nmap gcc guu~h<br/>  vmap gc gu~h<br/>endif<br/>\" automatically remove trailing whitespace before write<br/>function! StripTrailingWhitespace()<br/>  normal mZ<br/>  %s/\\s\\+$//e<br/>  if line(\"'Z\") != line(\".\")<br/>    echo \"Stripped whitespace\\n\"<br/>  endif<br/>  normal `Z<br/>endfunction<br/>autocmd BufWritePre *.rb,*.erb,*.haml,*.rake :call StripTrailingWhitespace()<br/><br/>\"ruby<br/>autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete<br/>autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1<br/>autocmd FileType ruby,eruby let g:rubycomplete_rails = 1<br/>autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1<br/>\"improve autocomplete menu color<br/>highlight Pmenu ctermbg=238 gui=bold<br/>
Tips###Linux###To Find something inside a file using regex:<br/>  egrep -n '[0-9]{3}\\.[0-9]ms' log/development.log <br/><br/>To use command line to get and post to sites:<br/>  wget -O- --no-check-certificate --post-data='filename=overview.en.html' https://projectdx:talk2me@california.beta.renewfund.com/cms_update/:site<br/><br/>To gain ROOT access to server with sudo:<br/><br/>It’s possible to enable passwordless sudo for the primary user. To do, SSH to your server and perform the following steps:<br/><br/>sudo su - # change to the root user<br/>visudo    # edit the sudoers file<br/><br/>If the username you’d like us to SSH in is named ‘deploy’, you’d add the following line to the end of the sudoers file:<br/><br/>deploy ALL=(ALL) NOPASSWD: ALL<br/>Save file and reboot.<br/><br/>To add a comment line at the top of each file:<br/>for file in `find . `; do echo '<!--'  $file  '-->' > /tmp/somefile; cat $file >> /tmp/somefile ; mv /tmp/somefile $file ; done<br/>
