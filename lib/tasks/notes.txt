(in /home/mmh/src/notes)
"Tips###Postgres###\\pset format unaligned, html, latex, aligned: changes the format of display.\r\n\\o to send output to a file.\r\n\r\nsudo apt-get install --reinstall\r\nscript/cucumber_selenium features/region_specific_content.feature \r\nrvm use ruby-1.8.7-p72@projectdx\r\n gem which factory_girl\r\n gem spec factory_girl\r\n git remote update\r\n git reset --hard origin/95904-region-context-without-address\r\n\r\nTo SSH to alpha:  ssh projectdx@alpha1\r\nTo SSH to prod: Go to Alpha and ssh projectdx@prod1\r\n\r\nMOM Database dumps: \r\n  ssh projectdx@mom.renewfund.com\r\n  cd /data/development/db_dumps\r\n\r\nBackup Projectdx CMS\r\n1. ssh projectdx@alpha.renewfund.com\r\n2. pg_dump -U projectdx cms > cms-10-4-2010.dump\r\n3. psql -U projectdx -d projectdx_cms_dev -f cms-10-4-2010.dump \r\n\r\n\r\nTo dump database schema off remote machine: dev1.renewfund.com:\r\n  pg_dump -s -h dev1.renewfund.com -U projectdx projectdx_dev -c > devschema.dump\r\n\r\nTo Restore schema: \r\n  RAILS_ENV=test rake db:drop\r\n  RAILS_ENV=test rake db:create \r\n  psql -Uprojectdx -d projectdx_test < devschema.dump\r\n\r\n\r\nList remote Databases: \r\n  psql -h dev1.renewfund.com -U projectdx -l\r\n\r\nOpen psql in remote database:\r\n  psql -h dev1.renewfund.com -U projectdx projectdx_test\r\n  psql -h dev1.renewfund.com -U projectdx projectdx_dev\r\n\r\nTo find references of git (when you make a mistake by killing a branch) \r\n- Get the log list from here:\r\n- cat .git/logs/refs/heads/101022-cms-news\r\n- Chery pick the branch commit number.\r\n\r\nTo Scan input and extract fourth term\r\n  awk '{print $4}' > ../failing\r\n\r\nTo Replace specific content of all files\r\n  find . -name *.erb | xargs sed -i 's/sytlesheet/stylesheet/'\r\n\r\nTo insert content at the first line of each file:\r\n  find . -name *.rb | xargs sed -i '1i #© Copyright, 2010, Zaytona.com, LLC' "
"SELECT###Postgres###Select DISTINCT: selects distinct row. \r\nSelect DISTINCT ON(): select distinct rows based on a set of fields."
"Setup Cucumber Database###Rails####!/usr/bin/env ruby\r\n\r\ncuke_env = ARGV.first\r\n\r\n%x{dropdb -U projectdx projectdx_\#{cuke_env}}\r\n%x{createdb -U projectdx -T projectdx_test projectdx_\#{cuke_env}}"
"Address in DelNorte###RF###284 Fresno St, Crescent City, California 95531"
"Restore Corrupt GIT Repo###GIT###I had managed to destroy my GIT repo on Dropbox, but I had a copy locally. The copy had all the branches cached locally including the origin/xxx branches (which are a cached of the remote branch).\r\n\r\nThe following article helped:\r\nhttp://stackoverflow.com/questions/2166005/how-to-restore-git-repository\r\n\r\nIn order to restore it (to github):\r\n\r\n1. Create an empty repo (git init --bare) or use github.\r\n2. Go to the local saved .git folder, and edit .git/config,\r\n3. Point the url of origin to the repo you just created,\r\n4. Run the following from the bash console:\r\n\r\nfor i in $(git branch -r | grep origin | sed 's#origin/##'); do git checkout $i; git push origin $i; done\r\n\r\nThis will checkout the branches locally and then push them to origin on the remote repo.\r\n"
"CAST###Postgres###Casts a value as a specific type.\r\nSELECT CAST('02/05/1984' as date);"
"LIKE and ILIKE delimters###Postgres###LIKE for wildcard matching\r\nILKIE for case insensitive wildcard matching\r\n(_) Underscore to match a single character\r\n(%) for wild pattern\r\n\r\nRegex"
"COALESCE###Postgres###Within a list, will find the first non-NULL value\r\nCOALESCE(column1, column2, column3, 'Unknown')\r\n= \r\nCASE\r\n  when column1 != NULL then column1\r\n  when column2 != NULL then column2\r\n  when column3 != NULL then column3\r\n  else 'Unknown'\r\nEND"
"ORDER BY [USING operator]###Postgres###Usually, ORDER BY uses the relational operators for comparison, the USING allows for using a different predicate operator for ordering the rows.\r\n"
"Aggregate###Postgres###COUNT(*): counts all rows\r\nCOUNT(expression): counts rows with expression != NULL: select COUNT(balance) from customers;\r\nCOUNT (ALL expression): Same as COUNT(expresssion)\r\nCOUNT(DISTINCT expression): counts number of distinct non-NULL rows.\r\n\r\nSUM(expression), AVG(expression), MIN(expression), MAX(expression): \r\n    Works on a single expression (not entire row) - ignores NULL\r\n\r\nSTDDEV(expression), VARIANCE(expression): "
"Where vs. Having###Postgres###http://www.codeproject.com/KB/database/Where_Vs_Having_Clause.aspx\r\n\r\nIf a condition refers to an aggregate function, put that condition in the HAVING clause. Otherwise, use the WHERE clause.\r\n\r\nHere's another rule: You can't use HAVING unless you also use GROUP BY.\r\n\r\nNow, go back to the first example, where WHERE and HAVING produce the same result set. What's the difference? The first query uses the WHERE clause to restrict the number of rows that the computer has to sum up. But the second query sums up all the rows in the table, then uses HAVING to discard the sums it calculated for all states except Texas and Georgia. The first query is obviously the better one, because there is no need to make the computer calculate sums and then throw them away. \r\n\r\n\r\nIntroduction\r\n\r\nWe always get confused between WHERE and Having clause and make mistakes. Here in this article, I will try to highlight all the major differences between WHERE and HAVING, and things you should be aware of, when using either WHERE or HAVING.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nMost of the time you will get the same result with Where or Having . The below given two SQL command produces the same result set That is, both count the number of records found for the states of California and Los Angles.\r\n\r\nSELECT state, COUNT(*)\r\nFROM Test\r\nWHERE state IN ('CA', 'LA')\r\nGROUP BY state\r\nORDER BY state\r\n\r\nSELECT state, COUNT(*)\r\nFROM Test\r\nGROUP BY state\r\nHAVING state IN ('CA', 'LA')\r\nORDER BY state\r\nBackground\r\n\r\n(Optional) So, where is the difference ,Which is better? I'll let you answer those questions in a minute.\r\n\r\nThe main reason for using WHERE clause is to select rows that are to be included in the query. For example, assume table Test.Suppose I want the names, account numbers, and balance due of all customers from California and Los Angles. Since STATE is one of the fields in the record format, I can use WHERE to select those customers.\r\nUsing the code\r\n\r\nSELECT cusnum, lstnam, init\r\nFROM Test\r\nWHERE state IN ('CA', 'LA')\r\n\r\nCUSNUM LSTNAM INIT BALDUE\r\n====== ============ ==== ========\r\n938472 John G K 37.00\r\n938485 Mark J A 3987.50\r\n593029 Lily E D 25.00\r\n\r\n\r\nSuppose I want the total amount due from customers by state. In that case, I would need to use the GROUP BY clause to build an aggregate query.\r\n\r\nSELECT state,SUM(baldue)\r\nFROM Test\r\nGROUP by state\r\nORDER BY state\r\n\r\nState Sum(Baldue)\r\n===== ===========\r\nCA 250.00\r\nCO 58.75\r\nGA 3987.50\r\nMN 510.00\r\nNY 589.50\r\nTX 62.00\r\nVT 439.00\r\nWY .00\r\n\r\nPoints of Interest\r\n\r\nSuppose I want the same information, but I don't care about states where nobody owes me any money. Since the total owed by state is an aggregate figure, i.e., the figure is generated from a group of records, you must use HAVING to select the proper data.\r\n\r\nSELECT state,SUM(baldue)\r\nFROM Test\r\nGROUP by state\r\nHAVING SUM(baldue) > 0\r\nORDER BY state\r\n\r\nState Sum(Baldue)\r\n===== ===========\r\nCA 250.00\r\nCO 58.75\r\nGA 3987.50\r\nMN 510.00\r\nNY 589.50\r\nTX 62.00\r\nVT 439.00 "
"If else: Based on success/failure of previous command###BASH####/bin/bash \r\n\r\n/bin/tar cvfz /test-bkp.tar.gz /opt*.dat \r\n\r\nif [ $? -eq 0 ] \r\nthen \r\necho \"backup is Successful \" \r\necho -e \"Backup path on NAS server is projects\" \r\nelse \r\necho \" backup failed \"  \r\nfi  "
"Find and Remove folders###BASH###find . -name *.svn* -exec rm -rf {} \\;\r\n\r\nNote the \\; at the end."
"VIM Tips###VIM###Select All: ggVG\r\nSwitch Buffers: Ctrl-w - L or R\r\nResize buffer: Ctrl - L,K,J, H"
"Correlated queries###SQL###Using Where with multiple columns \r\nselect z.id, a.id, a.zipcode_id from addresses a, zipcodes z where (z.id, a.zipcode_id) = (a.id, z.id) limit 100;\r\n\r\nUse multiple conditions on the JOIN:\r\nSELECT * FROM A join B on ((A.id < B.id) AND (A.age > B.age));\r\n\r\nUse inner queries (customers with the biggest rating): Uncorrelated query\r\n- Only need to evaluate inner query only once, and use it multiple times.\r\nSELECT C1.Number\r\nFROM Customer C1\r\nWHERE C1.CRating = (SELECT MAX(C2.CRating) FROM Customer C2);\r\n\r\nSOME: One or more (exists(1)):\r\nSELECT S.Number, S.Name\r\nFROM Salesperson S\r\nWHERE S.Name = SOME (SELECT C.Name from Customers C);\r\n\r\nALL: \r\n\r\nIN:\r\nSELECT S.Number, S.Name\r\nFROM Salesperson S\r\nWHERE S.Name IN (SELECT C.Name from Customers C);\r\n\r\n"
"Floorplanning######\r\nhttp://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5545492&isnumber=&tag=1"
"Floorplanning###Paper###\r\nhttp://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5545492&isnumber=&tag=1"
"CKEDITOR Plugin###CKEDITOR###http://www.sayopenweb.com/plugin-for-ckeditor/"
"Rspec Slides###RSPEC###http://kerryb.github.com/iprug-rspec-presentation/#65"
"Gem with Active Record###RSPEC###1. $:.unshift File.expand_path('../lib', __FILE__) \r\n\r\nAdd lib folder to path\r\n\r\n  2 ENV['RAILS_ENV']='test'                                                                                                 \r\n  3 require 'fileutils'                                                                                                     \r\n  4 require 'rubygems'                                                                                                      \r\n  5 require 'bundler'                                                                                                       \r\n  6 require 'bundler/setup'                                                                                                 \r\n  7 require 'rspec'                                                                                                         \r\n  8 require 'active_record'                                                                                                 \r\n  \r\nLoad active record here and in Gemfile.\r\n                                                                                                                        \r\n 10 Dir[\"\#{File.expand_path('../../lib', __FILE__)}/*.rb\"].each do |file|                                                   \r\n 11   require file                                                                                                          \r\n 12 end                                                                                                                     \r\n\r\n This requires all the files within this path.\r\n"
"Listen to TCP channel###Linux### sudo tcpdump -l -i lo0 -w - src or dst port 3000 | strings"
"Hidden Weighted Trit Functions###Quantum###you are in... Main\\hwbN functions\r\n\r\nHidden weighted bit function hwbN has N inputs and N outputs. Its output equals its input shifted left on the number of positions equal to the number of ones in the input pattern. Thus, hwbN function is reversible. Hidden weighted bit function is known to have an exponential size BDD for any variable ordering. This type functions were first proposed as reversible benchmarks by Patel and Markov. It is known that hwbN functions may be implemented with polynomial quantum/reversible cost assuming a logarithmic number of garbage bits is available. It remains an open question if a polynomial cost reversible/quantum implementation exists if addition of garbage bits is not allowed.\r\n\r\nThis is our adaptation to the ternary domain:\r\n\r\nHWT3:\r\n\r\n0\t0\t0\t\t0\t0\t0\r\n0\t0\t1\t\t0\t1\t0\r\n0\t0\t2\t\t0\t2\t0\r\n0\t1\t0\t\t1\t0\t0\r\n0\t1\t1\t\t1\t0\t1\r\n0\t1\t2\t\t2\t0\t1\r\n0\t2\t0\t\t2\t0\t0\r\n0\t2\t1\t\t1\t0\t2\r\n0\t2\t2\t\t2\t0\t2\r\n1\t0\t0\t\t0\t0\t1\r\n1\t0\t1\t\t1\t1\t0\r\n1\t0\t2\t\t2\t1\t0\r\n1\t1\t0\t\t0\t1\t1\r\n1\t1\t1\t\t1\t1\t1\r\n1\t1\t2\t\t1\t1\t2\r\n1\t2\t0\t\t0\t1\t2\r\n1\t2\t1\t\t1\t2\t1\r\n1\t2\t2\t\t1\t2\t2\r\n2\t0\t0\t\t0\t0\t2\r\n2\t0\t1\t\t1\t2\t0\r\n2\t0\t2\t\t2\t2\t0\r\n2\t1\t0\t\t0\t2\t1\r\n2\t1\t1\t\t2\t1\t1\r\n2\t1\t2\t\t2\t1\t2\r\n2\t2\t0\t\t0\t2\t2\r\n2\t2\t1\t\t2\t2\t1\r\n2\t2\t2\t\t2\t2\t2\r\n\r\n"
"VIMRC: Why VIM autocomplete did not work###VIM###For some strange reason, when I had 'set paste' in the file, VIM did not add the 'end' tag after\r\nI typed def test (and then hit enter).\r\n\r\n\r\nThis is my VIMRC file\r\n\r\n\r\ncall pathogen#runtime_append_all_bundles()\r\n\r\nset nocompatible          \" We're running Vim, not Vi!\r\nsyntax on                 \" Enable syntax highlighting\r\nfiletype plugin indent on \" Enable filetype-specific indenting and plugins\r\n\r\n\" Load matchit (% to bounce from do to end, etc.)\r\nruntime! macros/matchit.vim\r\n\r\naugroup myfiletypes\r\n  \" Clear old autocmds in group\r\n  autocmd!\r\n  \" autoindent with two spaces, always expand tabs\r\n  autocmd FileType ruby,eruby,yaml set ai sw=2 sts=2 et\r\naugroup END\r\n\r\nset hidden\r\nset directory=/tmp\r\nset backupdir=/tmp\r\nset tabstop=2\r\nset shiftwidth=2\r\nset expandtab\r\nset autoindent\r\nset nu\r\ncolorscheme ir_black\r\n\r\nnnoremap <silent> <F8> :TlistToggle<CR>\r\nvmap r \"_dP\r\n\r\nmap <F2> :NERDTreeToggle<CR>\r\n\r\nnnoremap <Leader>T :CommandTFlush <CR>\r\nnnoremap <Leader>t :CommandT <CR>\r\nnnoremap <Leader>a :Ack \r\n\r\nif (&tildeop)\r\n  nmap gcw guw~l\r\n  nmap gcW guW~l\r\n  nmap gciw guiw~l\r\n  nmap gciW guiW~l\r\n  nmap gcis guis~l\r\n  nmap gc$ gu$~l\r\n  nmap gcgc guu~l\r\n  nmap gcc guu~l\r\n  vmap gc gu~l\r\nelse\r\n  nmap gcw guw~h\r\n  nmap gcW guW~h\r\n  nmap gciw guiw~h\r\n  nmap gciW guiW~h\r\n  nmap gcis guis~h\r\n  nmap gc$ gu$~h\r\n  nmap gcgc guu~h\r\n  nmap gcc guu~h\r\n  vmap gc gu~h\r\nendif\r\n\" automatically remove trailing whitespace before write\r\nfunction! StripTrailingWhitespace()\r\n  normal mZ\r\n  %s/\\s\\+$//e\r\n  if line(\"'Z\") != line(\".\")\r\n    echo \"Stripped whitespace\\n\"\r\n  endif\r\n  normal `Z\r\nendfunction\r\nautocmd BufWritePre *.rb,*.erb,*.haml,*.rake :call StripTrailingWhitespace()\r\n\r\n\"ruby\r\nautocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete\r\nautocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1\r\nautocmd FileType ruby,eruby let g:rubycomplete_rails = 1\r\nautocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1\r\n\"improve autocomplete menu color\r\nhighlight Pmenu ctermbg=238 gui=bold\r\n"
"Tips###Linux###To Find something inside a file using regex:\r\n  egrep -n '[0-9]{3}\\.[0-9]ms' log/development.log \r\n\r\nTo use command line to get and post to sites:\r\n  wget -O- --no-check-certificate --post-data='filename=overview.en.html' https://projectdx:talk2me@california.beta.renewfund.com/cms_update/:site\r\n\r\nTo gain ROOT access to server with sudo:\r\n\r\nIt’s possible to enable passwordless sudo for the primary user. To do, SSH to your server and perform the following steps:\r\n\r\nsudo su - # change to the root user\r\nvisudo    # edit the sudoers file\r\n\r\nIf the username you’d like us to SSH in is named ‘deploy’, you’d add the following line to the end of the sudoers file:\r\n\r\ndeploy ALL=(ALL) NOPASSWD: ALL\r\nSave file and reboot.\r\n\r\nTo add a comment line at the top of each file:\r\nfor file in `find . `; do echo '<!--'  $file  '-->' > /tmp/somefile; cat $file >> /tmp/somefile ; mv /tmp/somefile $file ; done\r\n"
